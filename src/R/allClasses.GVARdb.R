###############################################################################
######## allClasses.GVARdb ####################################################
###############################################################################
#
# General description:
# This document defines all classes used in the GVARdb package:

### GVARdb: 
# Introducing a class holding all currently defined classes storing data on 
# genomic variants. (In the future this may be rewritten as an extention
# of the class GenomicFeatures of the GenomicFeatures package.)
setClass("GVARdb",contains="VIRTUAL")

## General Format:
.required_tables   <- c("data","map","qc","result","sample","metadata")
.required_colnames <- as.list(character(length(.required_tables)))
names(.required_colnames) <- .required_tables
.optional_colnames <- as.list(character(length(.required_tables)))
names(.optional_colnames) <- .required_tables

# Table 1) data: table containing primary data:
#	1.1) gvar_id: 		PRIMARY INTEGER KEY; an internal index
#	1.2) gvar_meas:		STRING; measurement ID
#	1.3) gvar_data:		STRING; all data from one feature concatenated (encoded)
#	1.4) gvar_allele:	STRING; format: *|*;
.required_colnames$data <- c("gvar_id","gvar_meas","gvar_data","gvar_allele")
#
# Table 2: map: table containing mapping data:
#   2.1) gvar_id:		PRIMARY INTEGER KEY; an internal index
#	2.2) chrom:			STRING;  chr1:22,X,Y,M    			--- when not mapped
#	2.3) start:			INTEGER;                    		  0 when not mapped
#	2.4) end:			INTEGER;                    		  0 when not mapped
#	2.5) gvar_name:		STRING; 	                 		--- when not mapped
#	2.6) strand:		STRING;  format: +/-/*;	 			--- when not mapped
#	2.7) map_incl:		NUMERIC; ordering	 	  	   		  0 when not given
.required_colnames$map <- c("gvar_id","chrom","start","end","gvar_name",
		"strand","map_incl")
#
# Table 3: qc: table containing data on quality control:
#   3.1) gvar_id:		PRIMARY INTEGER KEY; an internal index
#	3.2) qc_score_1		REAL;								   0 when not given
#	3.3) qc_score_*		(optional) REAL;					   0 when not given
#	3.4) qc_incl		REAL;					   			   0 when not given
.required_colnames$qc <- c("gvar_id","qc_score_1","qc_incl")
.optional_colnames$qc <- c("qc_score_*")

# Table 4: result: table containing results:
#   4.1) gvar_id:		PRIMARY INTEGER KEY; an internal index
#	4.2) stat_1:		NUMERIC; statistic, 		 		 999 when not given
#	4.3) stat_*:		(optional) NUMERIC; statistic, 		 999 when not given
# 	4.4) pval_1:		NUMERIC; p.value, 		 			 999 when not given
# 	4.5) pval_*:		(optional) NUMERIC; p.value, 		 999 when not given
.required_colnames$result <- c("gvar_id","stat_1","pval_1")
.optional_colnames$result <- c("stat_*","pval_*")

# Table 5) sample: table containing additional information on samples. 
# 	Most columns are optional, but are automatically created upon database 
#	initiation:
#	6.1) sample_id:		PRIMARY INTEGER KEY; an internal index
#   6.2) family:		STRING;  family ID;       			 --- when not given
#	6.3) member:		INTEGER; person ID;       			 999 when not given
#	6.4) father:		INTEGER; paternal ID;     			 999 when not given
#	6.5) mother:		INTEGER; maternal ID;     			 999 when not given
#	6.6) sex:			STRING;  MALE/FEMALE;     			 --- when not given
#	6.7) status_1:		STRING;	 CASE/CONTROL;    			 --- when not given
#	6.8) status_*:		(optional) STRING;	CASE/CONTROL;    --- when not given
#	6.8) QT_1:			NUMERIC; Quant. Trait     			 999 when not given
#	6.9) QT_*:			(optional) NUMERIC; Quant. Trait     999 when not given
#	6.10) sample_incl:	NUMERIC; incl & ordering	   		   0 when not given
.required_colnames$sample  <- c("sample_id","family","member","father",
	"mother","sex","status_1","QT_1","sample_incl")
.optional_colnames$sample  <- c("status_*","QT_*")

# Table 6) metadata: table containing additonal information on database creation.
#	Some values are autogenerated.
#	7.1) name:			description of metadata; STRING 
#	7.2) value:			value of metadata;	     STRING
.required_colnames$metadata       <- c("name","value")

# Within the table metadata, we minimally expect the following entries:
#		db_Type:		STRING; This stores the data type
.required_metanames <- c("dbType")

### GWASdb: 
# Extending GVARdb with a class suited for holding a connection to a SQLite 
# database containing tables holding GWAS data:
setClass("GWASdb",
		contains="GVARdb",
		representation(envir="environment"))

### impGWASdb:
# Extending GVARdb with a class suited for holding a connection to a SQLite 
# database containing tables holding imputed GWAS data:
setClass("impGWASdb",
		contains="GVARdb",
		representation(envir="environment"))

### INDELdb: 
# Extending GVARdb with a class suited for holding a connection to a SQLite 
# database containing tables holding INDEL data:
setClass("INDELdb",
		contains="GVARdb",
		representation(envir="environment"))

### METHdb:
# Extending GVARdb with a class suited for holding a connection to a SQLite 
# database containing tables holding METH(ylation) data:
setClass("METHdb",
		contains="GVARdb",
		representation(envir="environment"))

## Data storage format:
# Values of all observations per feature will be stored as one concatenated 
# string in the database. When querying the database, the appropriate strings 
# are returned and split in R. The reason for this is that the amount of 
# columns is limited for most types of databases in order to work efficiently. 
# Depending on the datatype, strings will be split and interpreted differently.
# GWASdb: 		0,1,2 for number of minor alleles and 9 for missing values.
#		=> string is split per character
# impGWASdb:	triplos of three digits to indicate posterior probabilities	of
#				genotypes. 000 till 999 with --- encoding for 1000
#		=> string is split per 3 characters and grouped in triples
# INDELdb:  	0,1 for the presence of an indel (0 = non measured/not present)
#		=> string is split per character
# METHdb:		duplos of three digits to indicate % of methylation in format:
#				# methylated reads # total reads. 000 till 999. 
#		=> string is split per 3 characters and grouped in duplos
#
### Misceleaneous definitions:
.colnames_data		<- c("gvar_meas","gvar_data","gvar_allele")
.colnames_bed   	<- c("chrom","start","end","gvar_name","strand")
.colnames_qc_data 	<- c("gvar_meas","qc_score_1","qc_incl")
.colnames_result_data <-  c("gvar_meas","stat_1","pval_1")
.colnames_pheno 	<- c("family","member","father","mother","sex","status_1",
		"QT_1","sample_incl")
.options_strand 	<- c("+","-","*")
.options_sex		<- c("MALE","FEMALE","---")
.options_status 	<- c("CASE","CONTROL","---")
.options_chrom  	<- c(paste("chr",c(as.character(1:22),"X","Y","M"),sep=""),
		"---")
.supported_classes 	<- 
		lapply(getClass("GVARdb")@subclasses, function(x) x@subClass)
.known_mappings		<- c("GRCh37/hg19_dbSNP132","GRCh37/hg19_dbSNP131",
							"NCBI36/hg18_dbSNP130","NCBI36/hg18_dbSNP129",
							"NCBI36/hg18_dbSNP128","NCBI36/hg18_dbSNP126",
							"NCBI35/hg17_dbSNP125")
.maxNQuery			<- 1000